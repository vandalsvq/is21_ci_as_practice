# Часть 1. Почему конфликты в Git обсуждают всем миром, а сравнение/объединение в 1С это нормально?

Прежде, чем говорить о том что такое Continuous Integration следует поговорить о цели, которую преследовали люди, стоящие у истоков этой идеи. Какую боль они пытались решить? А решали они боль совместной работы.

## Командная работа

Я постараюсь очень быстро об этом, поскольку тема крайне не нова и для большинства должна быть знакома. А в контексте использования Git-а так вообще не новость ни разу.

> Сразу оговорюсь, пока никакого gitflow, мы тут в принципе о проблеме говорим.. да и вообще, мне плевать на всех я коммичу сразу в мастер.

И так, вот у нас есть проект, master (или как теперь принято говорить main) - ветка и два программиста. Работать они пойдут как привыкли, взяли в задачу в трекере, завели feature-ветку и кодят. Один закончил быстрее, выполнил слияние в мастер. Второму понадобилось времени побольше. Он закончил позже, он начал слияние и получил конфликт. И вместо того, чтобы писать нужные фичи, разработчик тратит время и силы на разрешение конфликта.

` Эй парень, да ты это... хорош. У нас тут в 1С сравнение/объединение, а в EDT вообще по красоте запилили, не умеешь пользоваться так и скажи... не заливай нам тут. `

И чем сложнее объединить свою фичу с мастером. тем больше времени мы на это тратим. И это еще простой пример. В реальности то все куда веселее, у нас и задачи пишутся неделями и требования меняются и разработчиков может влезть побольше... в общем по-хорошему если все будут работать, а не как обычно 1 проект = 1 (ну ладно 2) программиста, вы эти конфликты решать устанете.

А давайте в эту задачу, к двум хорошим программистам добавим юного падавана. И вот у нас уже code-review.

> Если вы не в курсе что это, погуглите, а на самом деле я называю это "потешить свое самолюбие за счет унижения молодых и неопытных"

Практика то это правильная, но вот только работу тормозит будь здоров. Да и пример она дает еще более показательный. Вот наш юнец взял задачу, сделал, отправил запрос на проверку, подождал и взял следующую задачу... как собственно и программист, который его пример должен был посмотреть. И вот, спустя какое-то время, его задачу пропускают, ему надо слить с главной веткой и он ловит огромное количество конфликтов. Почему? Да потому что, пока его код висел на ревью, в коде много чего поменялось.

Ну и помимо истории с конфликтами, есть история с коммуникациями. Пока вы пилите вашу ненаглядную фичу в вашей отдельной веточке, часто ли вы сливаете код из основной ветки к вам? Скорее всего не так уж и часто, постепенно вы теряете связь с кодовой базой, возможно начинаете решать то, что уже решено вчера и можно чужой метод переиспользовать. Получается чем дольше вы работаете с устаревшей веткой, тем больше конфликтов надо решать, а чем больше конфликтов надо решать, тем меньше вы сливаете к себе изменения или тратите больше на это время. Круг то замкнутый получается... С

> Совместная работа - это больно всегда. Мы друг другу всегда мешаем.

## Continuous integration (непрерывная интеграция)

И на эту проблему обратили внимание уже очень давно, почти 30 лет назад.

> Впервые "Непрерывная интеграция" была концептуализирована и предложена Гради Бучем в 1991-м году, как один из элементов практики экстремального программирования. Это я узнал когда лекции в университете готовил.

Давайте разберем словосочетание Continuous integration. Дословно - это "непрерывная интеграция", но насколько "непрерывная" не ясно, и как глубоко "интеграция" тоже как бы сходу не скажешь. Поэтому предлагаю разобрать эти слова по отдельности.

### Integration

Как я говорил надо стремится, чтобы каждый работал с актуальной версией кода. Чтобы ветки как можно чаще сливались в основную, были как можно меньше, а конфликты не приводили к длительному процессу решения. Если коротко, то **integration** - это взять свой код и дотащить его до master.

### Continuous

А что считать непрерывностью? Подразумевается, что при выполнении любой задачи, мы стремимся интегрировать свой код в мастер как можно быстрее. В идеальном мире, каждые несколько часов. То есть берешь маленькую задачку, делаешь, merge-ишь в мастер. Все замечательно.

` Посмотри на него, какой красавец. Каждые несколько часов ему. А ты как сам в Git изменения сливаешь? Выгрузить в файлы, загрузить из файлов? Каждые несколько часов пересобирать опять? Ага... расскажи нам тут. `

Вот правда, тогда разработчик является ответственным за то, что он сделал, чтобы это работало и ничего не сломало. Вот тут то на сцену и выходит Jenkins, призванный помочь нам прогнать сборку, тесты и обновление.

И еще момент: изменения должны быть маленькими, задачки должны быть маленькими, настолько, что когда ее закончат - она не вызовает конфликт слияния. То есть не затронет ничьих интересов. И здесь уже никакой Jenkins не поможет. По той причине, что он просто инструмент... и что самое интересное, вы можете обойтись без него.

Но прежде чем, я продолжу дальше выступать поборником морали и практик, давайте немного о технике.

## Конфликты в Git и сравнение/объединение в 1С

Честно не знаю, что там в EDT. Каждая новая версия ни на миллиметр не дает к ней подступиться. Как минимум по причине отсутствия одного механизма - работы с поддержкой. Вот уж не знаю, как 1С пишет свои решения, но нам без оного тяжко будет. Ну и плюс, помните начало доклада: "работать надо, а не фантики разглядывать". Это скорее в шутку.

Так вот, мы работаем в обычном конфигураторе, в Git выгружаем командами "выгрузить в файлы" и "загрузить из файлов", нас это устраивает и времени много не отнимает. Однако, один механизм дико не радует, чтобы сравнить что-либо, чуть сложнее чем новый реквизит в объекте, порой необходимо собирать конфигурацию и сравнивать стандартным механизмом. И тут вроде надо сказать 1С спасибо, он вроде не так уж и плох (просто принято в России все наше ругать, а заморское хвалить). Но вот, на конфигурациях побольше очередной нетленки это обычно не вызывает бурю положительных эмоций. А главное никак не вписывается в непрерывность.

Что с этим делать? Честно, не сказать что знаю. Лично для себя я выработал некоторую стратегию:
* часто сливать изменения из рабочей ветки к себе (порой до нескольких раз в день);
* разбивать работу на как можно более мелкие задачи;
* сливать изменения раз в день или два.

Таким образом, часто мне получается собраться без использования конфигуратора 1С и cf-файлов. Fuckup-ы конечно происходят. Но в основном, по причине того, что я продолбал пересечение объектов. В любом случае общий порядок:
* сохранить свою конфигурацию;
* загрузить новую конфигурацию;
* сравнить с сохраненной ранее (чисто для подстраховки);
* продолжить работу.

Полчаса времени. Поэтому делаю это в минуты когда хочу посмотреть котиков, почитать книжки или просто отдохнуть.

И да, я хочу перейти на EDT как минимум потому, что работать с собранной конфигурацией не так приятно. В задачах на ближайшее время у меня это стоит. Но в силу своей позиции руководителя, мне приходится думать о таких простых вещах как: производительность команды, качество разработки, сложность входа новых сотрудников - сегодня и в перспективе.

Так что, мое мнение, надо стараться разрабатывать так, чтобы вызывать сравнение/объединение в штатном виде вам не очень то и надо было. Странно, да?

` Я скажу, а то он все стесняется. EDT наше все, на досуге пробовал плагинчики всякие покрутить, написал немного интеграции с системой учета задач, понравилось... `

<hr>


* [на главную страницу](..\README.md)