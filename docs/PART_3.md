# Перестаньте рекомендовать Gitflow

Накинуть на вентилятор - это не про меня. То о чем я сейчас буду говорить уже не новость. По крайней мере для меня, если об этом есть [ролик на Youtube](https://www.youtube.com/watch?v=v4Ijkq6Myfc) значит "это" уже в народе. Поэтому, давайте обойдемся без вопросов: да как ты смеешь? Я тут не причем, это все в этом вашем интернете написано. А начну я с [небольшой заметки](https://nvie.com/posts/a-successful-git-branching-model/) Винсента Дриссена к своей статье от 2010 года:

> Эта модель была задумана в 2010 году, то есть более 10 лет назад, и вскоре после появления самого Git. За эти 10 лет git-flow стала чрезвычайно популярной во многих командах разработчиков ПО до такой степени, что люди начали рассматривать ее как своего рода стандарт - и, к сожалению, также как догму или панацею.

> Если ваша команда использует непрерывную поставку ПО, я бы предложил гораздо более простой рабочий процесс, вместо того, чтобы внедрить git-flow в свою команду.

> Однако если вам необходимо поддерживать несколько версий ПО, то git-flow по-прежнему подходит для вашей команды так же хорошо, как и для многих последние 10 лет.

> Однако, всегда помните. Панацеи не существует. Учитывайте свой собственный контекст. Не нужно ненависти. Решайте сами.

Так в чем же проблема git-flow? Да собственно только в одном - дисциплина. Ветки feature могут жить примерно вечность. Ветка для выпуска релиза может тоже зависнуть на приличное такое время, поскольку некогда и некому поправить мелочи, найденные на этапе проверки релиза.

И все это сегодня я вижу у себя. Ну разве кроме ветки release. Они у нас создаются в основном по факту, так что там изменений то никаких нет.

Впрочем давайте поговорим о ветвлении подробнее. Мне понравилось сравнение "создания ПО с использованием веток" и детской игры, когда листок складывают на три части и каждый дорисовывает часть общего рисунка, не видя что нарисовал сосед. Обычно получается весело.

> можно пример в слайд

Чтобы такого не случалось, надо не скрывать изменения, а показывать их. Я бы даже сказал "демонстрировать". Ведь только тогда, картинка будет складной.

Вообще ветки в Git стоят дешево. В смысле что создание ветки - секунды. Ее поддержка - тоже секунды. Слияние между ними выполняется чаще всего без проблем. И эта легкость, с одной стороны помогает нам использовать их как можно более продуктивно, с другой стороны, как правило если что-то стоит дешево, то это не ценят. Так и здесь, никто за ними следить особо не хочет. Живет и ладно. Две версии правды? Три? Хотите будет столько, сколько одновременно может вести отдельно взятый программист умноженный на количество программистов и время жизни продукта.

И нет, я не призываю вас отказаться от ветвления. Я же не псих (хотя бы прикидываюсь здоровым). Но я хочу сказать что время жизни различий в этих ветках должно быть коротким.

## Немного о личном

Расскажу одну личную историю. И если мой коллега будет смотреть этот доклад, пусть подумает о своем поведении.

И так, есть у меня товарищ разработчик, со времен перехода на Git он не то чтобы его игнорирует, он с ним плохо дружит. Он как лакмусовая бумажка выражения "куй железо не отходя от кассы". Ну а поскольку в нашей компании чаще всего касса задачами старается быть наполнена, отойти от нее сложно. А еще, в силу высокой квалификации для него просто отсутствует дилемма "так оставить или переписать". Конечно переписать. "Да Саня первый же скажет какого опять костыли наплодили". Добавьте к этому высокую продуктивность и вы получите человека, который может за некоторый срок, создать проблемы половине команды, просто отрефакторив большой кусок старого легаси.

И вот такой человек, пропадает на неделю в своем диком рефакторинге, выходит из этого состояния и вдруг обнаруживает, что основная конфа куда то ушла. Ловит кучу проблем слияния, как-то героически их решает

> надо сказать что как правило очень хорошо, ибо потери чужой логики обычно не бывает

И вкатывает свои изменения веточкой длиной в пару минут и размером в половину конфы. Молодец? Безусловно. Надо так делать? Не уверен.

Вообще рефакторинг очень сложно уложить в CI, нужно действительно провести неплохую предварительную работу и все равно вылезет по пути много неожиданностей. Но все таки игра стоит свеч. Хотя бы потому, что как правило, тебе не придется рефакторить код твоих коллег, созданный в процессе твоего самоотверженного труда.

## Что использовать?

Внезапно я скажу так, все индивидуально. Это и простой и сложный ответ одновременно. Простой - потому что я снимаю ответственность с себя. А сложный - потому что я пришел с докладом, а значит задавая вопрос ты должен предложить варианты.

Вот я и предложу варианты:
* [GitHub Flow](https://guides.github.com/introduction/flow/#:~:text=GitHub%20flow%20is%20a%20lightweight,where%20deployments%20are%20made%20regularly.) - это легкий, основанный на ветках рабочий процесс, который поддерживает команды и проекты, в которых развертывание выполняется регулярно
* [Trunk-based development](https://paulhammant.com/2013/04/05/what-is-trunk-based-development/) - честно лучше спросит Google о ней. При чем я не в смысле поисковик, а в смысле компанию. Особенно про их монорепу. В ее основе лежит такая модель ветвления, в которой разработчики совместно работают над кодом в одной ветке, называемой «главной» (или master в терминологии Git). При этом второстепенные feature-ветки также могут создаваться, но они имеют короткий срок жизни.

    > После того, как разработчики долго используют Gitflow, данный подход может выглядеть наивным и примитивным, однако, для проектных команд, которые сфокусированы и стремятся продвигаться максимально быстро, именно такой подход может дать лучшие результаты.

Ну и на последок цитата от Линуса Торвальдса (батя Git-а кто не в курсе)

> Если ты выполняешь слияение каждый день, внезапно ты никогда не окажешься в точке где тебя будет ждать ужасный конфликт-слияния, который будет сложно решить.

И мне кажется этой мыслью стоит ограничиться. Ведь не важно, какая модель ветвления у вас, важно как вы подходите к скорости разработки, насколько вы готовы идти быстро.

<hr>

* [на главную страницу](../README.md)