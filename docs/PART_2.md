# Программист без интернета - это уже CI

Давайте немного представим следующую картину. Мы работаем локально (нормальная тема, интернет отвлекает), у нас нет Jenkins (типичный 1С-ник). Вы все еще можете взять и сделать себе локальную веточку. Написать в нее какой-то код, закрыть задачку за пару тройку часов, переключиться на master, выполнит слияние со своей веткой. И готово. У вас есть CI.

> Давайте вернем вам интернет (ну не Роскомнадзор же я) и попробуем поработать теперь снова.

И так, опять по-порядку: взяли задачу, открыли ветку, написали код, переключились на master, сделали git pull, выполнили слияние. И во снова CI. Так о чем это я тут уже столько времени разглагольствую?

> А теперь усложим задачу, пусть это будет не маленькая фича, а некий epic?

С переходом на более сложные задачи вы по-любому столкнетесь с невозможностью впихнуть невпихуемое. А именно сделать задачу за короткое время. А значит, декомпозиция и планирование. А помните про code-review? И его надо будет пересмотреть в сторону ускорения. А еще команду учить, объяснять им, идеологию в голову впихивать. Так что, просто поставить инструменты и сказать "а мы тут, у нас CI короче" не выйдет... быстро не выйдет, а долго выйдет.

Может пример в контексте разработки на 1С посмотрим? 

> Наша задача: новый документ, печатная форма, пара регистров и движения документа. Ну и до кучи по пути, аналитик подкидывает заполнение на основании, как нашего документа, так и других (уже из нашего). Ну давайте чтобы не сложно, документ будет простой. Счет на оплату.

Кто из вас сделает эту работу за 1 день? Я не говорю уже про пару часов. Значит давайте ее разбирать...

## Декомпозиция

В нашем случае составляющие документа "Счет на оплату":
* сам объект
* форма документа, форма списка, форма выбора
* модуль объекта и менеджера
* ну и до кучи: подписки на события, планы обмена, определяемые типы, критерии отбора, функциональные опции, общие команды.

Фуууух. Кажется все на поверхности.

### Объект

И так мое предложение, поскольку мы не хотим превращать жизнь наших коллег в локальный ад, а любой новый объект - это по-любому потенциальный конфликт слияния из-за как минимум файла Configuration.xml:

* первым делом нам надо объявить наш объект
* добавить все зависимые реквизиты от общих объектов метаданных (организация, документ-основание)
* добавить объект в функциональные опции, подписки на события, определяемые типы, критерии отбора, общие команды
* добавить отдельную роль на объект и исключить его из всех других ролей
* добавить (если нет) отдельную функциональную опцию "Тестовый функционал", который не включается у клиента. Ну вы наверное догадываетесь, зачем.

Логика проста, мы объявляем наш объект и уже изменяем много объектов ведущих к конфликтам. Но, нам надо постараться затронуть все объекты, которые доставят боль и страдания нашим коллегам. Когда мы это сделаем, мы зальем изменения и в будущем общие объекты уже постараемся не трогать. А наши изменения сосредоточатся в виде локальной работы внутри отдельного документа.

При наличии общей инструкции разработки для документов в каждой конфигурации (или в целом для компании), подобные изменения делаются за 1-2 часа, если не меньше. Заливаются, оповещаются все коллеги и вот уже как минимум при должной осмотрительности, они могут забрать его к себе и продолжить пилить свою "фичу".

### Формы

Здесь все просто, внешний вид форм - это xml, их модули отдельный файл bsl. Первый тяжело соединить средствами GIT-а, не умеет он это хорошо. Да и в случае пересечений изменений не обойтись без конфигуратора. Второй вполне может быть собран путем слияния с Git и загрузкой из файлов. При этом вероятность конфликта мала, при должной осмотрительности. Поэтому, сначала накидываем форму, методы из элементов формы, минимальное поведение, заливаем, предупреждаем товарищей. Далее пилим внутреннюю логику - ваши изменения в модулях, не так уж страшны.

### Модуль объекта и модуль менеджера

Такие одинаковые и разные одновременно. Пожалуй о них стоило упомянуть еще в секции про сам объект. Модуль менеджера может содержать полезную логику для ваших коллег, поэтому возможно стоит объявить хотя бы заголовки методов до заливки объекта. Но только если у вас есть какие-либо соглашения об обязательных методах. Впрочем, сделай вы это позже, bsl файлы легко объединяются самим Git-ом.

Про модуль объекта либо хорошо, либо ничего, поскольку его изменения никого, кроме вас пока не интересуют. Так что пилите, Шура, пилите.

### Движения и новые регистры

Считаю, что объявлять сразу нет никакого смысла. Для начала достаточно дать форму документа для тестов, описания сценариев работы и инструкций, ну и по пути напилить движения. Тем более, как правило, большинству пользователей глубоко без разницы какие движения вы делаете. Лишь бы отчеты были красивыми. А красивые отчеты они вам все равно не расскажут сразу и в лоб. А то что придумают аналитики - у реальных пользователей вызовет желание их выгнать. Так что, сделаете позже, но по методике добавления объекта. То есть четко, быстро, дерзко и без дополнений.

> Аналогично стоит разобрать и другие объекты, все до одного. Посмотреть на их пересечения и взаимодействия и выработать стратегию как вы декомпозируете задачи. Ну и потом это втолковать аналитикам, научиться таким образом их ставить, ну и не терять общую логику развития системы. Что достаточно тяжело.

## Пруфы в студию

В 21-м веке, если ты не привел ссылки, то не считается. Как с бегом, не выложил - не побегал. Поэтому давайте по пруфам.

Есть такая контора Google, говорят умные ребята, но это не точно, хотя вероятно. Так вот, у них есть ежегодное такое исследование State of DevOps ([вот вам за 2019-й год](https://services.google.com/fh/files/misc/state-of-devops-2019.pdf)). Так вот они, нашли четкую корреляцию между компаниями, которые стараются использовать короткоживущие ветки, которые интегрируются быстро, часто и показателями производительности IT. И измерили это безобразие они 4-мя показателями:

1. Deployment frequency - частота развертывания
2. Lead time for changes - скорость внесения изменений
3. Time to restore service - время восстановления работоспособности
4. Change failure rate - частота "отказных" изменений

| Aspect of Software Delivery Performance | Elite | High | Medium | Low |
|----------------------------------------|-------|------|-------|-----| 
| Deployment frequency | On-demand (multiple deploys per day) | Between once per day and once per week | Between once per week and once per month | Between once per month and once every six months |
| Lead time for changes | Less than one day | Between one day and one week | Between one week and one month | Between one month and six months
| Time to restore service | Less than one hour | Less than one day | Less than one day | Between one week and one month
| Change failure rate | 0-15% | 0-15% | 0-15% | 46-60%

Прикол в том, что большинство из вас, если вдруг немного прикроют один глаз (ну чтобы бревно видно не было) вдруг обнаружат себя среди компаний с высокой степенью эффективности доставки ПО. Правда цена вопроса? Вот в нашей компании она строго коррелирует с исполнителем и его желанием работать сверхурочно.

Но я, как любой докладчик должен перевернуть историю в свою пользу, поэтому неожиданно для вас и с очень умным лицом приведу еще одну ссылку на Technology Radar ([а там про Gitflow и у кого-то сейчас знатно рванет](https://www.thoughtworks.com/radar/techniques/long-lived-branches-with-gitflow))

<hr>

* [на главную страницу](../README.md)